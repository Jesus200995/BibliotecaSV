from typing import List, Optional, Dict, Any, Tuple
import asyncpg
from datetime import datetime
from app.database import db_manager
from app.schemas import (
    Archivo, ArchivoCreate, ArchivoUpdate, ArchivoConCampos,
    Campo, CampoCreate, FiltrosArchivo, ArchivoResponse,
    EstadisticasResponse
)
import math

class ArchivoService:
    
    @staticmethod
    async def listar_archivos(filtros: FiltrosArchivo) -> ArchivoResponse:
        """Listar archivos con filtros y paginación"""
        async with db_manager.get_connection() as conn:
            # Construir WHERE clause
            where_conditions = []
            params = []
            param_count = 0
            
            if filtros.busqueda:
                param_count += 1
                where_conditions.append(f"""
                    (LOWER(nombre_archivo) LIKE ${param_count} OR 
                     LOWER(descripcion) LIKE ${param_count} OR 
                     LOWER(tema) LIKE ${param_count})
                """)
                params.append(f"%{filtros.busqueda.lower()}%")
            
            if filtros.tipo_archivo:
                param_count += 1
                where_conditions.append(f"LOWER(tipo_archivo) = ${param_count}")
                params.append(filtros.tipo_archivo.lower())
            
            if filtros.tema:
                param_count += 1
                where_conditions.append(f"LOWER(tema) = ${param_count}")
                params.append(filtros.tema.lower())
            
            if filtros.entidad:
                param_count += 1
                where_conditions.append(f"LOWER(entidad) = ${param_count}")
                params.append(filtros.entidad.lower())
            
            if filtros.municipio:
                param_count += 1
                where_conditions.append(f"LOWER(municipio) = ${param_count}")
                params.append(filtros.municipio.lower())
            
            if filtros.territorio:
                param_count += 1
                where_conditions.append(f"LOWER(territorio) = ${param_count}")
                params.append(filtros.territorio.lower())
            
            if filtros.responsable:
                param_count += 1
                where_conditions.append(f"LOWER(responsable) = ${param_count}")
                params.append(filtros.responsable.lower())
            
            if filtros.nivel_validacion:
                param_count += 1
                where_conditions.append(f"LOWER(nivel_validacion) = ${param_count}")
                params.append(filtros.nivel_validacion.lower())
            
            if filtros.fecha_desde:
                param_count += 1
                where_conditions.append(f"fecha_actualizacion >= ${param_count}")
                params.append(filtros.fecha_desde)
            
            if filtros.fecha_hasta:
                param_count += 1
                where_conditions.append(f"fecha_actualizacion <= ${param_count}")
                params.append(filtros.fecha_hasta)
            
            where_clause = "WHERE " + " AND ".join(where_conditions) if where_conditions else ""
            
            # Contar total
            count_query = f"SELECT COUNT(*) FROM catalogo_archivos {where_clause}"
            total = await conn.fetchval(count_query, *params)
            
            # Calcular paginación
            offset = (filtros.pagina - 1) * filtros.por_pagina
            total_paginas = math.ceil(total / filtros.por_pagina)
            
            # Obtener archivos
            param_count += 1
            limit_param = param_count
            param_count += 1
            offset_param = param_count
            
            query = f"""
                SELECT id, nombre_archivo, descripcion, tipo_archivo, fecha_actualizacion,
                       tamano_bytes, etiquetas, ruta_archivo, tema, entidad, municipio,
                       territorio, responsable, fuente, nivel_validacion, observaciones
                FROM catalogo_archivos 
                {where_clause}
                ORDER BY fecha_actualizacion DESC
                LIMIT ${limit_param} OFFSET ${offset_param}
            """
            
            rows = await conn.fetch(query, *params, filtros.por_pagina, offset)
            
            archivos = [
                Archivo(
                    id=row['id'],
                    nombre_archivo=row['nombre_archivo'],
                    descripcion=row['descripcion'],
                    tipo_archivo=row['tipo_archivo'],
                    fecha_actualizacion=row['fecha_actualizacion'],
                    tamano_bytes=row['tamano_bytes'],
                    etiquetas=row['etiquetas'] or [],
                    ruta_archivo=row['ruta_archivo'],
                    tema=row['tema'],
                    entidad=row['entidad'],
                    municipio=row['municipio'],
                    territorio=row['territorio'],
                    responsable=row['responsable'],
                    fuente=row['fuente'],
                    nivel_validacion=row['nivel_validacion'],
                    observaciones=row['observaciones']
                )
                for row in rows
            ]
            
            return ArchivoResponse(
                archivos=archivos,
                total=total,
                pagina=filtros.pagina,
                por_pagina=filtros.por_pagina,
                total_paginas=total_paginas
            )
    
    @staticmethod
    async def obtener_archivo_por_id(archivo_id: int) -> Optional[ArchivoConCampos]:
        """Obtener archivo por ID con sus campos"""
        async with db_manager.get_connection() as conn:
            # Obtener archivo
            archivo_query = """
                SELECT id, nombre_archivo, descripcion, tipo_archivo, fecha_actualizacion,
                       tamano_bytes, etiquetas, ruta_archivo, tema, entidad, municipio,
                       territorio, responsable, fuente, nivel_validacion, observaciones
                FROM catalogo_archivos WHERE id = $1
            """
            archivo_row = await conn.fetchrow(archivo_query, archivo_id)
            
            if not archivo_row:
                return None
            
            # Obtener campos
            campos_query = """
                SELECT id, archivo_id, nombre_campo, tipo_campo, descripcion, orden
                FROM archivo_campos 
                WHERE archivo_id = $1 
                ORDER BY orden, nombre_campo
            """
            campos_rows = await conn.fetch(campos_query, archivo_id)
            
            campos = [
                Campo(
                    id=row['id'],
                    archivo_id=row['archivo_id'],
                    nombre_campo=row['nombre_campo'],
                    tipo_campo=row['tipo_campo'],
                    descripcion=row['descripcion'],
                    orden=row['orden']
                )
                for row in campos_rows
            ]
            
            return ArchivoConCampos(
                id=archivo_row['id'],
                nombre_archivo=archivo_row['nombre_archivo'],
                descripcion=archivo_row['descripcion'],
                tipo_archivo=archivo_row['tipo_archivo'],
                fecha_actualizacion=archivo_row['fecha_actualizacion'],
                tamano_bytes=archivo_row['tamano_bytes'],
                etiquetas=archivo_row['etiquetas'] or [],
                ruta_archivo=archivo_row['ruta_archivo'],
                tema=archivo_row['tema'],
                entidad=archivo_row['entidad'],
                municipio=archivo_row['municipio'],
                territorio=archivo_row['territorio'],
                responsable=archivo_row['responsable'],
                fuente=archivo_row['fuente'],
                nivel_validacion=archivo_row['nivel_validacion'],
                observaciones=archivo_row['observaciones'],
                campos=campos
            )
    
    @staticmethod
    async def crear_archivo(archivo: ArchivoCreate) -> Archivo:
        """Crear nuevo archivo"""
        async with db_manager.get_connection() as conn:
            query = """
                INSERT INTO catalogo_archivos (
                    nombre_archivo, descripcion, tipo_archivo, tamano_bytes, etiquetas,
                    ruta_archivo, tema, entidad, municipio, territorio, responsable,
                    fuente, nivel_validacion, observaciones
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                RETURNING id, nombre_archivo, descripcion, tipo_archivo, fecha_actualizacion,
                         tamano_bytes, etiquetas, ruta_archivo, tema, entidad, municipio,
                         territorio, responsable, fuente, nivel_validacion, observaciones
            """
            row = await conn.fetchrow(
                query,
                archivo.nombre_archivo,
                archivo.descripcion,
                archivo.tipo_archivo,
                archivo.tamano_bytes,
                archivo.etiquetas,
                archivo.ruta_archivo,
                archivo.tema,
                archivo.entidad,
                archivo.municipio,
                archivo.territorio,
                archivo.responsable,
                archivo.fuente,
                archivo.nivel_validacion,
                archivo.observaciones
            )
            
            return Archivo(**dict(row))
    
    @staticmethod
    async def obtener_estadisticas() -> EstadisticasResponse:
        """Obtener estadísticas generales"""
        async with db_manager.get_connection() as conn:
            # Total de archivos
            total_archivos = await conn.fetchval("SELECT COUNT(*) FROM catalogo_archivos")
            
            # Archivos por tipo
            tipos_rows = await conn.fetch("""
                SELECT tipo_archivo, COUNT(*) as cantidad
                FROM catalogo_archivos 
                WHERE tipo_archivo IS NOT NULL
                GROUP BY tipo_archivo
                ORDER BY cantidad DESC
            """)
            archivos_por_tipo = {row['tipo_archivo']: row['cantidad'] for row in tipos_rows}
            
            # Archivos por tema
            temas_rows = await conn.fetch("""
                SELECT tema, COUNT(*) as cantidad
                FROM catalogo_archivos 
                WHERE tema IS NOT NULL
                GROUP BY tema
                ORDER BY cantidad DESC
            """)
            archivos_por_tema = {row['tema']: row['cantidad'] for row in temas_rows}
            
            # Archivos por entidad
            entidades_rows = await conn.fetch("""
                SELECT entidad, COUNT(*) as cantidad
                FROM catalogo_archivos 
                WHERE entidad IS NOT NULL
                GROUP BY entidad
                ORDER BY cantidad DESC
            """)
            archivos_por_entidad = {row['entidad']: row['cantidad'] for row in entidades_rows}
            
            # Tamaño total
            tamano_total_bytes = await conn.fetchval("""
                SELECT COALESCE(SUM(tamano_bytes), 0) FROM catalogo_archivos
            """) or 0
            tamano_total_mb = tamano_total_bytes / (1024 * 1024)
            
            return EstadisticasResponse(
                total_archivos=total_archivos,
                archivos_por_tipo=archivos_por_tipo,
                archivos_por_tema=archivos_por_tema,
                archivos_por_entidad=archivos_por_entidad,
                tamano_total_mb=round(tamano_total_mb, 2)
            )
    
    @staticmethod
    async def obtener_valores_filtros() -> Dict[str, List[str]]:
        """Obtener valores únicos para filtros"""
        async with db_manager.get_connection() as conn:
            # Tipos de archivo
            tipos = await conn.fetch("""
                SELECT DISTINCT tipo_archivo 
                FROM catalogo_archivos 
                WHERE tipo_archivo IS NOT NULL
                ORDER BY tipo_archivo
            """)
            
            # Temas
            temas = await conn.fetch("""
                SELECT DISTINCT tema 
                FROM catalogo_archivos 
                WHERE tema IS NOT NULL
                ORDER BY tema
            """)
            
            # Entidades
            entidades = await conn.fetch("""
                SELECT DISTINCT entidad 
                FROM catalogo_archivos 
                WHERE entidad IS NOT NULL
                ORDER BY entidad
            """)
            
            # Municipios
            municipios = await conn.fetch("""
                SELECT DISTINCT municipio 
                FROM catalogo_archivos 
                WHERE municipio IS NOT NULL
                ORDER BY municipio
            """)
            
            # Territorios
            territorios = await conn.fetch("""
                SELECT DISTINCT territorio 
                FROM catalogo_archivos 
                WHERE territorio IS NOT NULL
                ORDER BY territorio
            """)
            
            # Responsables
            responsables = await conn.fetch("""
                SELECT DISTINCT responsable 
                FROM catalogo_archivos 
                WHERE responsable IS NOT NULL
                ORDER BY responsable
            """)
            
            # Niveles de validación
            niveles = await conn.fetch("""
                SELECT DISTINCT nivel_validacion 
                FROM catalogo_archivos 
                WHERE nivel_validacion IS NOT NULL
                ORDER BY nivel_validacion
            """)
            
            return {
                "tipos_archivo": [row['tipo_archivo'] for row in tipos],
                "temas": [row['tema'] for row in temas],
                "entidades": [row['entidad'] for row in entidades],
                "municipios": [row['municipio'] for row in municipios],
                "territorios": [row['territorio'] for row in territorios],
                "responsables": [row['responsable'] for row in responsables],
                "niveles_validacion": [row['nivel_validacion'] for row in niveles]
            }
